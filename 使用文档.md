# C++ åå°„ç³»ç»Ÿä½¿ç”¨æ–‡æ¡£

æœ¬æ–‡æ¡£ä»‹ç»å¦‚ä½•ä½¿ç”¨é™æ€åå°„å’ŒåŠ¨æ€åå°„ç³»ç»Ÿï¼ŒåŒ…æ‹¬ç±»å‹æ³¨å†Œã€å‡½æ•°è°ƒç”¨ã€æ•°æ®è®¿é—®ç­‰åŠŸèƒ½ã€‚

---

## ç›®å½•

1. [å¿«é€Ÿå¼€å§‹](#å¿«é€Ÿå¼€å§‹)
2. [é™æ€åå°„](#é™æ€åå°„)
3. [åŠ¨æ€åå°„](#åŠ¨æ€åå°„)
4. [Anyç±»å‹](#anyç±»å‹)
5. [å·¥å…·ç±»](#å·¥å…·ç±»)

---

## å¿«é€Ÿå¼€å§‹

### å®šä¹‰ä¸€ä¸ªç±»

```cpp
class Person {
public:
    std::string name;
    int age;
    std::vector<std::string> friends;

    const std::string& getName() const { return name; }
    void setName(const std::string& n) { name = n; }
    int getAge() const { return age; }
};
```

---

## é™æ€åå°„

é™æ€åå°„åœ¨**ç¼–è¯‘æœŸ**æä¾›ç±»å‹ä¿¡æ¯ï¼Œé›¶è¿è¡Œæ—¶å¼€é”€ï¼Œå®Œå…¨ç±»å‹å®‰å…¨ã€‚

### 1. æ³¨å†Œç±»å‹

ä½¿ç”¨å®æ³¨å†Œéœ€è¦åå°„çš„ç±»å‹ï¼š

```cpp
#include "static_refl/reflect_core.h"

BEGIN_REFLECT(Person)
BASE_CLASSES()  // å¦‚æœæœ‰åŸºç±»ï¼Œå†™åœ¨è¿™é‡Œï¼šBASE_CLASSES(BaseClass1, BaseClass2)

functions(
    func(&Person::getName),
    func(&Person::setName),
    func(&Person::getAge)
)

variables(
    var(&Person::name),
    var(&Person::age)
)

containers(
    container(&Person::friends)
)

END_REFLECT()
```

### 2. è®¿é—®æˆå‘˜å˜é‡

**æ–¹å¼1ï¼šç›´æ¥é€šè¿‡æŒ‡é’ˆè®¿é—®**ï¼ˆæ¨è - é›¶å¼€é”€ï¼‰ï¼š

```cpp
using PersonType = my_reflect::static_refl::TypeData<Person>;

Person p{"Alice", 25};

// è·å–å­—æ®µ
constexpr auto person_vars = PersonType::variables;
auto name_field = std::get<0>(person_vars);  // nameå­—æ®µ
auto age_field = std::get<1>(person_vars);   // ageå­—æ®µ

// è¯»å–å€¼
std::cout << p.*name_field.ptr_ << "\n";     // Alice
std::cout << p.*age_field.ptr_ << "\n";      // 25

// ä¿®æ”¹å€¼
p.*name_field.ptr_ = "Bob";
p.*age_field.ptr_ = 30;
```

**æ–¹å¼2ï¼šæŒ‰ç´¢å¼•è®¿é—®**ï¼š

```cpp
// æŒ‰ç´¢å¼•è·å–ï¼ˆç´¢å¼•ä»0å¼€å§‹ï¼‰
const auto& name = PersonType::get<0>(p);    // è·å–name
const auto& age = PersonType::get<1>(p);     // è·å–age

// æŒ‰ç´¢å¼•è®¾ç½®
PersonType::set<0>(p, std::string("Charlie"));
PersonType::set<1>(p, 35);

// è·å–å¼•ç”¨å¹¶ä¿®æ”¹
auto& age_ref = PersonType::get<1>(p);
age_ref = 40;
```

**æ–¹å¼3ï¼šç¼–è¯‘æœŸåå­—æŸ¥æ‰¾ + æŒ‰ç´¢å¼•è®¿é—®**ï¼š

```cpp
// ç¼–è¯‘æœŸæŸ¥æ‰¾å˜é‡ç´¢å¼•
constexpr int name_idx = PersonType::find_variable_index("name");
constexpr int age_idx = PersonType::find_variable_index("age");

// ç¼–è¯‘æœŸæ£€æŸ¥å˜é‡æ˜¯å¦å­˜åœ¨
if constexpr (name_idx >= 0) {
    const auto& name = PersonType::get<name_idx>(p);
    PersonType::set<name_idx>(p, std::string("David"));
}

// æŸ¥æ‰¾ä¸å­˜åœ¨çš„å˜é‡è¿”å› -1
constexpr int notFound = PersonType::find_variable_index("nonExistent");  // -1
```

### 3. è°ƒç”¨æˆå‘˜å‡½æ•°

**æ–¹å¼1ï¼šç›´æ¥è°ƒç”¨**ï¼ˆæ¨è - é›¶å¼€é”€ï¼‰ï¼š

```cpp
constexpr auto person_funcs = PersonType::functions;
auto getName_field = std::get<0>(person_funcs);

// è°ƒç”¨å‡½æ•°
std::string name = (p.*getName_field.ptr_)();
```

**æ–¹å¼2ï¼šæŒ‰ç´¢å¼•è°ƒç”¨**ï¼š

```cpp
// æŒ‰ç´¢å¼•è°ƒç”¨ï¼ˆç´¢å¼•ä»0å¼€å§‹ï¼‰
auto name = PersonType::invoke<0>(p);        // è°ƒç”¨getName
auto age = PersonType::invoke<2>(p);         // è°ƒç”¨getAge

PersonType::invoke<1>(p, "Charlie");         // è°ƒç”¨setName
```

**æ–¹å¼3ï¼šç¼–è¯‘æœŸåå­—æŸ¥æ‰¾ + è°ƒç”¨**ï¼š

```cpp
// ç¼–è¯‘æœŸæŸ¥æ‰¾å‡½æ•°ç´¢å¼•
constexpr int getName_idx = PersonType::find_function_index("getName");
constexpr int setName_idx = PersonType::find_function_index("setName");

// ç¼–è¯‘æœŸæ£€æŸ¥å‡½æ•°æ˜¯å¦å­˜åœ¨
if constexpr (getName_idx >= 0) {
    auto result = PersonType::invoke<getName_idx>(p);
}

// æŸ¥æ‰¾ä¸å­˜åœ¨çš„å‡½æ•°è¿”å› -1
constexpr int notFound = PersonType::find_function_index("nonExistent");  // -1
```

### 4. è®¿é—®å®¹å™¨

```cpp
constexpr auto person_containers = PersonType::containers;
auto friends_field = std::get<0>(person_containers);

// è®¿é—®å®¹å™¨
(p.*friends_field.ptr_).push_back("David");
std::cout << (p.*friends_field.ptr_).size() << "\n";
```

### 5. æŸ¥è¯¢ç±»å‹ä¿¡æ¯

```cpp
using PersonType = my_reflect::static_refl::TypeData<Person>;

// è·å–ç±»å‹åˆ—è¡¨
using FunctionTypes = PersonType::function_types;   // å‡½æ•°ç±»å‹åˆ—è¡¨
using VariableTypes = PersonType::variable_types;   // å˜é‡ç±»å‹åˆ—è¡¨
using ContainerTypes = PersonType::container_types; // å®¹å™¨ç±»å‹åˆ—è¡¨

// è·å–æ•°é‡ï¼ˆç¼–è¯‘æœŸå¸¸é‡ï¼‰
constexpr size_t func_count = my_reflect::static_refl::size_v<FunctionTypes>;
constexpr size_t var_count = my_reflect::static_refl::size_v<VariableTypes>;

// æŸ¥è¯¢å­—æ®µä¿¡æ¯
auto name_field = std::get<0>(PersonType::variables);
std::cout << name_field.name_ << "\n";           // å­—æ®µå
std::cout << name_field.is_variable() << "\n";   // æ˜¯å¦æ˜¯å˜é‡
std::cout << name_field.is_member() << "\n";     // æ˜¯å¦æ˜¯æˆå‘˜
```

---

## åŠ¨æ€åå°„

åŠ¨æ€åå°„åœ¨**è¿è¡Œæ—¶**æä¾›ç±»å‹ä¿¡æ¯ï¼Œæ”¯æŒç±»å‹æ“¦é™¤å’Œè¿è¡Œæ—¶æŸ¥è¯¢ã€‚

### 1. æ³¨å†Œç±»å‹

```cpp
#include "dynamic_refl/dynamic_reflect_core.h"

namespace dyn_ref = my_reflect::dynamic_refl;

// æ³¨å†ŒåŸºç¡€ç±»å‹ï¼ˆå¦‚æœéœ€è¦ï¼‰
dyn_ref::Register<std::string>().Register("std::string");
dyn_ref::Register<int>().Register("int");

// æ³¨å†Œç±»
dyn_ref::Register<Person>()
    .Register("Person")
    .Add("getName", &Person::getName)
    .Add("setName", &Person::setName)
    .Add("getAge", &Person::getAge)
    .Add<decltype(&Person::name)>("name")
    .Add<decltype(&Person::age)>("age")
    .Add<decltype(&Person::friends)>("friends");
```

### 2. è¿è¡Œæ—¶æŸ¥è¯¢ç±»å‹

```cpp
// æŒ‰åå­—æŸ¥æ‰¾ç±»å‹
const dyn_ref::Type* personType = dyn_ref::GetType("Person");

std::cout << personType->GetName() << "\n";      // Person
std::cout << (int)personType->GetKind() << "\n"; // ç±»å‹ç§ç±»

// è½¬æ¢ä¸ºå…·ä½“ç±»å‹
const dyn_ref::Class* personClass = personType->AsClass();
const dyn_ref::Enum* enumType = someType->AsEnum();
const dyn_ref::Arithmetic* arithType = someType->AsArithmetic();
```

### 3. éå†ç±»æˆå‘˜

```cpp
const dyn_ref::Class* personClass = dyn_ref::GetType("Person")->AsClass();

// éå†æˆå‘˜å‡½æ•°
for (const auto& func : personClass->memberFunctions_) {
    std::cout << "Function: " << func.name_ << "\n";
}

// éå†æˆå‘˜å˜é‡
for (const auto& var : personClass->memberVariables_) {
    std::cout << "Variable: " << var.name_ << "\n";
}

// éå†å®¹å™¨æˆå‘˜
for (const auto& container : personClass->memberContainers_) {
    std::cout << "Container: " << container.name_ << "\n";
}
```

### 4. ä½¿ç”¨Anyè¿›è¡Œè¿è¡Œæ—¶æ“ä½œ

è¯¦è§ä¸‹ä¸€èŠ‚ [Anyç±»å‹](#anyç±»å‹)ã€‚

---

## Anyç±»å‹

`Any`æ˜¯ç±»å‹æ“¦é™¤çš„åŒ…è£…å™¨ï¼Œå­˜å‚¨ä»»æ„ç±»å‹çš„å¯¹è±¡å¹¶ä¿ç•™åå°„ä¿¡æ¯ã€‚

### 1. åˆ›å»ºAnyå¯¹è±¡

```cpp
Person p{"Alice", 25};

// å››ç§å­˜å‚¨æ–¹å¼
auto any1 = dyn_ref::make_copy(p);   // æ‹·è´å­˜å‚¨
auto any2 = dyn_ref::make_move(std::move(p)); // ç§»åŠ¨å­˜å‚¨
auto any3 = dyn_ref::make_ref(p);    // å¼•ç”¨å­˜å‚¨ï¼ˆä¸æŒæœ‰æ‰€æœ‰æƒï¼‰
auto any4 = dyn_ref::make_cref(p);   // constå¼•ç”¨å­˜å‚¨
```

### 2. ä»Anyä¸­æå–å€¼

```cpp
// any_cast è·å–æŒ‡é’ˆï¼ˆå¤±è´¥è¿”å›nullptrï¼‰
Person* ptr = dyn_ref::any_cast<Person>(any3);
if (ptr) {
    std::cout << ptr->name << "\n";
}

// any_get è·å–optionalï¼ˆå¤±è´¥è¿”å›nulloptï¼‰
std::optional<int> value = dyn_ref::any_get<int>(int_any);
if (value) {
    std::cout << *value << "\n";
}
```

### 3. Anyä¸Šçš„æ“ä½œ

#### ç®—æœ¯ç±»å‹æ“ä½œ

```cpp
int x = 42;
auto x_any = dyn_ref::make_copy(x);

// é€šç”¨æ“ä½œï¼ˆLayer 1ï¼‰
dyn_ref::any_set(x_any, 100);
auto result = dyn_ref::any_get<int>(x_any);  // 100

// ç±»å‹æ£€æŸ¥æ“ä½œï¼ˆLayer 2ï¼‰
const dyn_ref::Arithmetic* arithType = x_any.typeInfo->AsArithmetic();
if (arithType) {
    arithType->SetValue(x_any, 200);
    auto value = arithType->GetValue<int>(x_any);
}
```

#### æšä¸¾ç±»å‹æ“ä½œ

```cpp
enum class Color { Red, Green, Blue };

// æ³¨å†Œæšä¸¾
dyn_ref::Register<Color>()
    .Register("Color")
    .Value("Red", Color::Red)
    .Value("Green", Color::Green)
    .Value("Blue", Color::Blue);

Color c = Color::Red;
auto c_any = dyn_ref::make_copy(c);

const dyn_ref::Enum* enumType = dyn_ref::GetType("Color")->AsEnum();

// æŒ‰åå­—è®¾ç½®
enumType->SetByName(c_any, "Green");

// æŒ‰å€¼è®¾ç½®
enumType->SetByValue(c_any, 2);  // Blue

// è·å–åå­—
std::optional<std::string> name = enumType->GetName(c_any);  // "Blue"

// è·å–å€¼
std::optional<long long> value = enumType->GetValue(c_any);  // 2
```

#### å®¹å™¨æ“ä½œ

```cpp
std::vector<int> vec = {1, 2, 3};
auto vec_any = dyn_ref::make_ref(vec);

// éœ€è¦MemberContainerä¿¡æ¯
auto containerInfo = dyn_ref::MemberContainer::Create<std::vector<int>>("vec");

// è·å–å¤§å°
size_t sz = dyn_ref::container_ops::Size(containerInfo, vec_any);

// æ·»åŠ å…ƒç´ 
auto value_any = dyn_ref::make_copy(42);
dyn_ref::container_ops::Push(containerInfo, vec_any, value_any);

// è®¿é—®å…ƒç´ 
auto elem = dyn_ref::container_ops::At(containerInfo, vec_any, 0);

// æ¸…ç©º
dyn_ref::container_ops::Clear(containerInfo, vec_any);
```

**Mapæ“ä½œ**ï¼š

```cpp
std::map<std::string, int> scores;
auto map_any = dyn_ref::make_ref(scores);
auto mapInfo = dyn_ref::MemberContainer::Create<std::map<std::string, int>>("scores");

// æ’å…¥é”®å€¼å¯¹
auto key = dyn_ref::make_copy(std::string("Math"));
auto val = dyn_ref::make_copy(95);
dyn_ref::container_ops::InsertKV(mapInfo, map_any, key, val);

// è·å–å€¼
auto result = dyn_ref::container_ops::GetValue(mapInfo, map_any, key);

// æ£€æŸ¥é”®æ˜¯å¦å­˜åœ¨
bool exists = dyn_ref::container_ops::ContainsKey(mapInfo, map_any, key);
```

### 4. é€šè¿‡Anyè°ƒç”¨å‡½æ•°

**æ–¹å¼1ï¼šé€šè¿‡Classç±»æŸ¥æ‰¾å¹¶è°ƒç”¨**ï¼š

```cpp
Person p{"Alice", 25};
auto p_any = dyn_ref::make_ref(p);

const dyn_ref::Class* personClass = dyn_ref::GetType("Person")->AsClass();

// æŸ¥æ‰¾å‡½æ•°
const dyn_ref::MemberFunction* func = personClass->FindFunction("getName");

// è°ƒç”¨å‡½æ•°
std::vector<dyn_ref::Any> args;  // æ— å‚æ•°
auto result = func->Invoke(p_any, args);

// å¸¦å‚æ•°è°ƒç”¨
const dyn_ref::MemberFunction* setNameFunc = personClass->FindFunction("setName");
std::string newName = "Bob";
std::vector<dyn_ref::Any> args2;
args2.push_back(dyn_ref::make_ref(newName));
setNameFunc->Invoke(p_any, args2);
```

**æ–¹å¼2ï¼šç›´æ¥ç”¨Any.invokeï¼ˆæ¨èï¼‰**ï¼š

```cpp
Person p{"Alice", 25};
auto p_any = dyn_ref::make_ref(p);

// æŒ‰åå­—è°ƒç”¨
auto name = p_any.invoke("getName");
std::cout << *dyn_ref::any_cast<std::string>(name) << "\n";

// å¸¦å‚æ•°è°ƒç”¨
std::string newName = "Charlie";
p_any.invoke("setName", newName);

// æŒ‰ç´¢å¼•è°ƒç”¨
auto age = p_any.invoke(2);  // è°ƒç”¨ç¬¬2ä¸ªå‡½æ•°

// å¤šå‚æ•°è°ƒç”¨
p_any.invoke("speak", std::string("Hello"), 5);
```

---

## å·¥å…·ç±»

### 1. type_list æ“ä½œ

```cpp
using namespace my_reflect::static_refl;

using list1 = type_list<int, double, char>;

// è·å–å¤§å°
constexpr size_t sz = size_v<list1>;  // 3

// è·å–å…ƒç´ 
using first = front_t<list1>;   // int
using last = back_t<list1>;     // char
using second = get_t<list1, 1>; // double

// æ·»åŠ å…ƒç´ 
using list2 = push_t<std::string, list1>;  // type_list<std::string, int, double, char>

// å¼¹å‡ºå…ƒç´ 
using list3 = pop_t<list1>;  // type_list<double, char>
```

### 2. ç±»å‹ç‰¹å¾æŸ¥è¯¢

```cpp
// å­—æ®µç‰¹å¾æŸ¥è¯¢
auto field = std::get<0>(PersonType::functions);
field.is_function();      // æ˜¯å¦æ˜¯å‡½æ•°
field.is_variable();      // æ˜¯å¦æ˜¯å˜é‡
field.is_const();         // æ˜¯å¦æ˜¯const
field.is_member();        // æ˜¯å¦æ˜¯æˆå‘˜
field.param_count();      // å‚æ•°æ•°é‡

// å®¹å™¨ç‰¹å¾æŸ¥è¯¢
auto container_field = std::get<0>(PersonType::containers);
container_field.is_container();   // æ˜¯å¦æ˜¯å®¹å™¨
container_field.container_kind(); // å®¹å™¨ç±»å‹ï¼šSet/Vector/Map
```

### 3. å‡½æ•°ç‰¹å¾æå–

```cpp
// å‡½æ•°ç±»å‹ç‰¹å¾
using GetNameFunc = decltype(&Person::getName);
using traits = my_reflect::static_refl::function_traits<GetNameFunc>;

using RetType = traits::return_type;          // const std::string&
using ParamTypes = traits::parameter_type;    // type_list<>
constexpr bool isConst = traits::is_const;    // true
constexpr bool isMember = traits::is_member;  // true
constexpr size_t paramCount = traits::parameter_count; // 0
```

### 4. å®¹å™¨ç‰¹å¾æå–

```cpp
using FriendsType = std::vector<std::string>;
using container_traits = my_reflect::static_refl::container_traits<FriendsType>;

using value_type = container_traits::value_type;  // std::string
constexpr auto kind = container_traits::kind;     // ContainerKind::Vector

// åˆ¤æ–­æ˜¯å¦æ˜¯å®¹å™¨
constexpr bool isContainer = my_reflect::static_refl::is_container_v<FriendsType>;
```

---

## å®Œæ•´ç¤ºä¾‹

### é™æ€åå°„å®Œæ•´ç¤ºä¾‹

```cpp
#include "static_refl/reflect_core.h"
#include <iostream>

class Person {
public:
    std::string name;
    int age;

    const std::string& getName() const { return name; }
    void setName(const std::string& n) { name = n; }
};

BEGIN_REFLECT(Person)
BASE_CLASSES()
functions(
    func(&Person::getName),
    func(&Person::setName)
)
variables(
    var(&Person::name),
    var(&Person::age)
)
END_REFLECT()

int main() {
    using PersonType = my_reflect::static_refl::TypeData<Person>;

    Person p{"Alice", 25};

    // è®¿é—®å˜é‡ï¼ˆæ–¹å¼1ï¼šç›´æ¥é€šè¿‡æŒ‡é’ˆï¼‰
    auto name_field = std::get<0>(PersonType::variables);
    std::cout << "Name: " << p.*name_field.ptr_ << "\n";

    // è®¿é—®å˜é‡ï¼ˆæ–¹å¼2ï¼šæŒ‰ç´¢å¼•ï¼‰
    const auto& name = PersonType::get<0>(p);
    std::cout << "get<0>: " << name << "\n";

    // è®¿é—®å˜é‡ï¼ˆæ–¹å¼3ï¼šç¼–è¯‘æœŸæŸ¥æ‰¾ï¼‰
    constexpr int name_idx = PersonType::find_variable_index("name");
    if constexpr (name_idx >= 0) {
        PersonType::set<name_idx>(p, std::string("Bob"));
        std::cout << "After set: " << PersonType::get<name_idx>(p) << "\n";
    }

    // è°ƒç”¨å‡½æ•°ï¼ˆæ–¹å¼1ï¼šç›´æ¥ï¼‰
    auto getName_field = std::get<0>(PersonType::functions);
    std::cout << "getName(): " << (p.*getName_field.ptr_)() << "\n";

    // è°ƒç”¨å‡½æ•°ï¼ˆæ–¹å¼2ï¼šæŒ‰ç´¢å¼•ï¼‰
    std::cout << "invoke<0>: " << PersonType::invoke<0>(p) << "\n";

    // è°ƒç”¨å‡½æ•°ï¼ˆæ–¹å¼3ï¼šç¼–è¯‘æœŸæŸ¥æ‰¾ï¼‰
    constexpr int idx = PersonType::find_function_index("getName");
    if constexpr (idx >= 0) {
        std::cout << "By index: " << PersonType::invoke<idx>(p) << "\n";
    }

    return 0;
}
```

### åŠ¨æ€åå°„å®Œæ•´ç¤ºä¾‹

```cpp
#include "dynamic_refl/dynamic_reflect_core.h"
#include <iostream>

class Person {
public:
    std::string name;
    int age;

    const std::string& getName() const { return name; }
    void setName(const std::string& n) { name = n; }
};

int main() {
    namespace dyn_ref = my_reflect::dynamic_refl;

    // æ³¨å†Œç±»å‹
    dyn_ref::Register<Person>()
        .Register("Person")
        .Add("getName", &Person::getName)
        .Add("setName", &Person::setName);

    // åˆ›å»ºå¯¹è±¡å’ŒAny
    Person p{"Alice", 25};
    auto p_any = dyn_ref::make_ref(p);

    // é€šè¿‡Anyè°ƒç”¨å‡½æ•°
    auto name = p_any.invoke("getName");
    std::cout << "getName(): "
              << *dyn_ref::any_cast<std::string>(name) << "\n";

    // ä¿®æ”¹
    p_any.invoke("setName", std::string("Bob"));
    std::cout << "After setName: " << p.name << "\n";

    return 0;
}
```

---

## æ€§èƒ½å¯¹æ¯”

| ç‰¹æ€§ | é™æ€åå°„ | åŠ¨æ€åå°„ |
|------|---------|---------|
| **ç±»å‹æ£€æŸ¥** | ç¼–è¯‘æœŸ | è¿è¡ŒæœŸ |
| **å‡½æ•°è°ƒç”¨** | é›¶å¼€é”€ï¼ˆå†…è”ï¼‰ | è™šå‡½æ•°å¼€é”€ |
| **åå­—æŸ¥æ‰¾** | ç¼–è¯‘æœŸ | è¿è¡ŒæœŸçº¿æ€§æœç´¢ |
| **çµæ´»æ€§** | éœ€è¦çŸ¥é“å…·ä½“ç±»å‹ | å®Œå…¨ç±»å‹æ“¦é™¤ |
| **ä½¿ç”¨åœºæ™¯** | æ€§èƒ½å…³é”®è·¯å¾„ | æ’ä»¶ç³»ç»Ÿã€åºåˆ—åŒ– |

---

## å¸¸è§é—®é¢˜

**Q: é™æ€åå°„èƒ½æŒ‰åå­—è°ƒç”¨å‡½æ•°å—ï¼Ÿ**

A: å¯ä»¥é€šè¿‡`find_function_index`åœ¨ç¼–è¯‘æœŸæŸ¥æ‰¾ç´¢å¼•ï¼Œç„¶åç”¨`invoke<index>`è°ƒç”¨ã€‚ä¸æ”¯æŒçº¯è¿è¡Œæ—¶æŒ‰åå­—è°ƒç”¨ï¼Œå› ä¸ºä¸åŒå‡½æ•°è¿”å›ç±»å‹ä¸åŒã€‚

**Q: åŠ¨æ€åå°„å’Œé™æ€åå°„å¯ä»¥ä¸€èµ·ä½¿ç”¨å—ï¼Ÿ**

A: å¯ä»¥ï¼å®ƒä»¬æ˜¯ç‹¬ç«‹çš„ç³»ç»Ÿï¼Œå¯ä»¥åŒæ—¶ä½¿ç”¨ã€‚é™æ€åå°„ç”¨äºæ€§èƒ½å…³é”®ä»£ç ï¼ŒåŠ¨æ€åå°„ç”¨äºçµæ´»çš„è¿è¡Œæ—¶æ“ä½œã€‚

**Q: Anyçš„å››ç§å­˜å‚¨æ–¹å¼å¦‚ä½•é€‰æ‹©ï¼Ÿ**

A:
- `make_copy`: éœ€è¦æŒæœ‰æ‰€æœ‰æƒ
- `make_move`: æ¥ç®¡å¯¹è±¡æ‰€æœ‰æƒ
- `make_ref`: ä¸´æ—¶å¼•ç”¨ï¼Œå¯¹è±¡ç”Ÿå‘½å‘¨æœŸç”±å¤–éƒ¨ç®¡ç†
- `make_cref`: åªè¯»å¼•ç”¨

**Q: å®¹å™¨æ“ä½œä¸ºä»€ä¹ˆéœ€è¦MemberContainerå‚æ•°ï¼Ÿ**

A: å› ä¸ºå®¹å™¨æ“ä½œæ˜¯ç±»å‹æ“¦é™¤çš„ï¼Œéœ€è¦MemberContainerä¸­å­˜å‚¨çš„å‡½æ•°æŒ‡é’ˆæ¥æ‰§è¡Œå®é™…æ“ä½œã€‚

---

## æ€»ç»“

- **é™æ€åå°„**ï¼šç¼–è¯‘æœŸã€é›¶å¼€é”€ã€ç±»å‹å®‰å…¨ï¼Œé€‚åˆæ€§èƒ½æ•æ„Ÿçš„åœºæ™¯
- **åŠ¨æ€åå°„**ï¼šè¿è¡ŒæœŸã€çµæ´»ã€æ”¯æŒç±»å‹æ“¦é™¤ï¼Œé€‚åˆæ’ä»¶ã€åºåˆ—åŒ–ç­‰åœºæ™¯
- **Anyç±»å‹**ï¼šç±»å‹æ“¦é™¤å®¹å™¨ï¼Œæ¡¥æ¥é™æ€ç±»å‹å’ŒåŠ¨æ€åå°„
- ä¸¤ç§åå°„ç³»ç»Ÿäº’è¡¥ï¼Œæ ¹æ®å®é™…éœ€æ±‚é€‰æ‹©ä½¿ç”¨

ç¥ä½¿ç”¨æ„‰å¿«ï¼ğŸ‰
