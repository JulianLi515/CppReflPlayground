# C++ 反射系统技术文档

## 1. 架构概述

本反射系统采用**双轨制设计**，提供静态反射（编译期）和动态反射（运行期）两种方式：

- **静态反射**：零运行时开销，编译期类型安全，基于模板元编程
- **动态反射**：运行时灵活性，类型擦除，基于 `Any` 类型

两种方式可以互补使用，静态反射用于性能敏感场景，动态反射用于需要运行时多态的场景。

### 核心设计模式

1. **类型擦除（Type Erasure）**：使用 `std::function` 和虚函数实现类型无关的操作
2. **模板元编程**：编译期类型推导和代码生成
3. **宏辅助生成**：使用宏简化反射信息注册，宏内包含必要的模板函数和辅助函数
4. **双层 API 设计**：通用操作（any_set/any_get）+ 类型特定验证方法

## 2. 目录结构

```
CppReflPlayground/
├── include/
│   ├── static_refl/          # 静态反射（编译期）
│   │   ├── reflect_core.h    # 核心宏和工具
│   │   ├── field_traits.h    # 字段特征提取
│   │   ├── function_traits.h # 函数特征提取
│   │   ├── variable_traits.h # 变量特征提取
│   │   ├── container_traits.h# 容器特征检测
│   │   └── type_list.h       # 编译期类型列表
│   └── dynamic_refl/         # 动态反射（运行期）
│       ├── dynamic_reflect_core.h  # 动态反射核心
│       ├── Type.h            # 类型基类
│       ├── Class.h           # 类类型元数据
│       ├── Enum.h            # 枚举类型元数据
│       ├── Arithmetic.h      # 算术类型元数据
│       ├── Pointer.h         # 指针类型元数据
│       ├── Void.h            # void 类型
│       ├── Any.h             # 类型擦除容器
│       ├── invoke_impl.h     # 函数调用实现
│       ├── MemberFunction.h  # 成员函数元数据
│       ├── MemberVariable.h  # 成员变量元数据
│       ├── MemberContainer.h # 成员容器元数据
│       ├── container_operations.h # 容器操作
│       └── TypeRegistry.h    # 全局类型注册表
└── src/
    └── dynamic_refl/         # 动态反射实现文件
        ├── Type.cpp
        ├── Class.cpp
        ├── Enum.cpp
        ├── Arithmetic.cpp
        ├── MemberFunction.cpp
        ├── MemberVariable.cpp
        ├── MemberContainer.cpp
        ├── Any.cpp
        └── TypeRegistry.cpp
```

---

## 3. 静态反射模块（static_refl/）

### 3.1 reflect_core.h

**作用**：静态反射的核心头文件，提供反射注册宏和编译期工具函数

**关键内容**：

1. **TypeData 结构体模板**：存储类型的所有反射信息
   ```cpp
   template <typename T>
   struct TypeData {
       using type = T;
       static constexpr std::string_view name = /* ... */;
       static constexpr auto fields = /* tuple */;
       static constexpr auto functions = /* tuple */;
   };
   ```

2. **注册宏**：
   - `REFLECT_TYPE_BEGIN(Type)`：开始类型注册
   - `REFLECT_TYPE_END()`：结束类型注册
   - `fields(...)`：注册字段（变量或容器）
   - `functions(...)`：注册函数

3. **辅助函数命名空间 `detail`**：
   - `find_function_index_impl`：编译期查找函数索引
   - `invoke_by_index_impl`：编译期按索引调用函数
   - `find_variable_index_impl`：编译期查找变量索引
   - `get_by_index_impl`：按索引获取变量
   - `set_by_index_impl`：按索引设置变量
   - **设计原则**：复杂的模板逻辑在 `detail` 命名空间实现，宏内定义简洁的包装函数

4. **编译期查询接口**：
   - **函数相关**：
     - `find_function_index(name)`：返回函数名对应的编译期索引
     - `invoke<Index>(instance, args...)`：按索引调用成员函数
   - **变量相关**：
     - `find_variable_index(name)`：返回变量名对应的编译期索引
     - `get<Index>(instance)`：按索引获取变量值
     - `set<Index>(instance, value)`：按索引设置变量值

**设计亮点**：
- 使用 `std::tuple` 存储字段和函数，支持编译期遍历
- 使用 `std::index_sequence` 实现编译期循环
- 复杂模板逻辑封装在 `detail` 命名空间，宏内只生成必要的包装代码

---

### 3.2 field_traits.h

**作用**：提取字段（成员变量或成员函数指针）的类型信息

**关键内容**：

```cpp
template <auto Ptr>
struct field_traits;

// 成员变量指针特化
template <typename ClassT, typename MemberT, MemberT ClassT::*Ptr>
struct field_traits<Ptr> {
    using class_type = ClassT;
    using member_type = MemberT;
    static constexpr auto ptr_ = Ptr;
    static constexpr bool is_function = false;
};

// 成员函数指针特化
template <typename ClassT, typename RetT, typename... ParamT,
          RetT(ClassT::*Ptr)(ParamT...)>
struct field_traits<Ptr> {
    using class_type = ClassT;
    using member_type = RetT(ClassT::*)(ParamT...);
    using function_type = RetT(ParamT...);
    static constexpr auto ptr_ = Ptr;
    static constexpr bool is_function = true;
};
```

**设计亮点**：
- 使用 `auto` 模板参数统一处理变量和函数指针
- 存储原始指针值 `ptr_`，可直接用于访问或调用
- 提供 `is_function` 编译期区分字段类型

---

### 3.3 function_traits.h

**作用**：提取函数签名信息（返回类型、参数类型等）

**关键内容**：

```cpp
// 成员函数特化
template <typename ClassT, typename RetT, typename... ParamT>
struct function_traits<RetT(ClassT::*)(ParamT...)> {
    using class_type = ClassT;
    using return_type = RetT;
    using parameter_type = type_list<ParamT...>;
    static constexpr size_t parameter_count = sizeof...(ParamT);
    static constexpr bool is_member = true;
    static constexpr bool is_const = false;
};

// const 成员函数特化
template <typename ClassT, typename RetT, typename... ParamT>
struct function_traits<RetT(ClassT::*)(ParamT...) const> { /* ... */ };
```

**支持的函数类型**：
- 全局函数指针
- 静态函数指针
- 成员函数指针
- const 成员函数指针

**配合使用**：在 `MemberFunction::Create` 中用于提取参数类型列表

---

### 3.4 variable_traits.h

**作用**：提取成员变量指针的类型信息

**关键内容**：

```cpp
template <auto Ptr>
struct variable_traits;

template <typename ClassT, typename MemberT, MemberT ClassT::*Ptr>
struct variable_traits<Ptr> {
    using class_type = ClassT;
    using member_type = MemberT;
    static constexpr auto ptr_ = Ptr;
};
```

**与 field_traits 的区别**：
- `field_traits` 是通用提取器（变量 + 函数）
- `variable_traits` 专门用于变量指针，提供更语义化的接口

---

### 3.5 container_traits.h

**作用**：编译期检测类型是否为容器，并提取容器元素类型

**关键内容**：

```cpp
// 检测是否为容器
template <typename T, typename = void>
struct is_container : std::false_type {};

template <typename T>
struct is_container<T, std::void_t<
    typename T::value_type,
    typename T::iterator,
    decltype(std::declval<T>().begin()),
    decltype(std::declval<T>().end()),
    decltype(std::declval<T>().size())
>> : std::true_type {};

template <typename T>
inline constexpr bool is_container_v = is_container<T>::value;

// 提取元素类型
template <typename T>
struct container_element_type {
    using type = typename T::value_type;
};
```

**支持的容器**：
- 标准库容器（vector, list, deque, set, map 等）
- 自定义容器（需满足迭代器和 size() 接口）

**配合使用**：在 `ClassFactory::Add` 中判断成员是否为容器

---

### 3.6 type_list.h

**作用**：编译期类型列表，用于存储和操作类型序列

**关键内容**：

```cpp
template <typename... Ts>
struct type_list {
    static constexpr size_t size = sizeof...(Ts);
};

// 获取指定索引的类型
template <typename List, size_t Index>
struct get;

template <size_t Index, typename... Ts>
struct get<type_list<Ts...>, Index> {
    using type = /* 第 Index 个类型 */;
};

template <typename List, size_t Index>
using get_t = typename get<List, Index>::type;

// 从 tuple 生成 type_list
template <typename Tuple>
using type_list_from_tuple_t = /* ... */;
```

**用途**：
- 存储函数参数类型列表
- 在 `MemberFunction::InvokeImpl` 中按索引提取参数类型
- 配合 `std::index_sequence` 实现编译期循环

---

## 4. 动态反射模块（dynamic_refl/）

### 4.1 Type.h / Type.cpp

**作用**：动态反射类型系统的基类，定义类型的公共接口

**关键内容**：

```cpp
class Type {
public:
    enum class Kind { Void, Arithmetic, Pointer, Enum, Class };

    const std::string& GetName() const;
    Kind GetKind() const;

    // 类型转换（安全向下转型）
    const Class* AsClass() const;
    const Enum* AsEnum() const;
    const Arithmetic* AsArithmetic() const;

protected:
    std::string name_;
    Kind kind_;
};
```

**设计模式**：
- **类型安全的向下转型**：AsClass/AsEnum/AsArithmetic 返回指针，失败返回 nullptr
- **运行时类型识别**：通过 `Kind` 枚举区分类型类别

---

### 4.2 Class.h / Class.cpp

**作用**：表示类类型的元数据，存储成员变量、成员函数、容器等信息

**关键内容**：

```cpp
class Class : public Type {
public:
    std::vector<const Class*> baseClasses_;       // 基类列表
    std::vector<MemberFunction> memberFunctions_; // 成员函数
    std::vector<MemberVariable> memberVariables_; // 成员变量
    std::vector<MemberContainer> memberContainers_; // 成员容器

    // 通过 Any 访问成员
    Any GetMemberValue(Any& instance, const std::string& memberName) const;
    bool SetMemberValue(Any& instance, const std::string& memberName, const Any& value) const;

    // 查找函数（用于 invoke）
    const MemberFunction* FindFunction(const std::string& name) const;
};
```

**注册工厂**：

```cpp
template <typename T>
class ClassFactory {
public:
    static ClassFactory& Instance();

    ClassFactory& Register(const std::string& name);

    template <typename U>
    ClassFactory& Add(const std::string& name, U ptr) {
        if constexpr(std::is_member_function_pointer_v<U>) {
            info_.AddFunc(MemberFunction::Create<U>(name, ptr));
        } else if constexpr (std::is_member_object_pointer_v<U>) {
            // 提取成员类型
            using MemberType = /* ... */;
            if constexpr (is_container_v<MemberType>) {
                info_.AddContainer(MemberContainer::Create<MemberType>(name));
            } else {
                info_.AddVar(MemberVariable::Create<U>(name));
            }
        }
        return *this;
    }
};
```

**设计亮点**：
- 使用 `if constexpr` 在编译期区分函数指针、容器和普通变量
- 支持基类链（继承关系）
- 提供类型擦除的成员访问接口

---

### 4.3 MemberFunction.h / MemberFunction.cpp

**作用**：存储成员函数的元数据，并提供类型擦除的调用接口

**关键内容**：

```cpp
class MemberFunction {
public:
    std::string name_;
    const Type* retType_;                    // 返回类型
    std::vector<const Type*> argTypes_;      // 参数类型列表

    // 类型擦除的调用器
    std::function<Any(Any&, const std::vector<Any>&)> invoker_;

    // 通过 Any 调用
    Any Invoke(Any& instance, const std::vector<Any>& args) const;

    // 工厂方法：从函数指针创建
    template <typename FuncPtr>
    static MemberFunction Create(const std::string& name, FuncPtr funcPtr);
};
```

**核心实现**：

```cpp
template <typename FuncPtr>
static MemberFunction Create(const std::string& name, FuncPtr funcPtr) {
    using Traits = function_traits<FuncPtr>;
    using RetType = typename Traits::return_type;
    using ArgTypes = typename Traits::parameter_type; // type_list
    using ClassType = typename Traits::class_type;

    // 创建类型擦除的调用器
    auto invoker = [funcPtr](Any& instance, const std::vector<Any>& args) -> Any {
        return InvokeImpl<FuncPtr, ArgTypes>(
            funcPtr, instance, args,
            std::make_index_sequence<ArgTypes::size>{}
        );
    };

    return MemberFunction{
        name,
        GetType<RetType>(),
        TypeListToVector<ArgTypes>(),
        std::move(invoker)
    };
}
```

**InvokeImpl 实现**：

```cpp
template <typename FuncPtr, typename ArgTypes, size_t... Is>
static Any InvokeImpl(FuncPtr funcPtr, Any& instance,
                      const std::vector<Any>& args,
                      std::index_sequence<Is...>) {
    using ClassType = /* ... */;
    using RetType = /* ... */;

    ClassType* inst = any_cast<ClassType>(instance);
    if (!inst) throw std::runtime_error("Type mismatch");

    if constexpr (std::is_void_v<RetType>) {
        (inst->*funcPtr)(ExtractArg<get_t<ArgTypes, Is>>(args[Is])...);
        return Any{};
    } else {
        RetType result = (inst->*funcPtr)(ExtractArg<get_t<ArgTypes, Is>>(args[Is])...);
        return make_copy(result);
    }
}
```

**设计亮点**：
- 使用 lambda 捕获函数指针，实现类型擦除
- 使用 `std::index_sequence` 展开参数包
- 自动处理 void 返回类型

---

### 4.4 MemberVariable.h / MemberVariable.cpp

**作用**：存储成员变量的元数据，提供类型擦除的读写接口

**关键内容**：

```cpp
class MemberVariable {
public:
    std::string name_;
    const Type* type_;

    // 类型擦除的访问器
    std::function<Any(const Any&)> getter_;
    std::function<bool(Any&, const Any&)> setter_;

    template <typename MemberPtr>
    static MemberVariable Create(const std::string& name) {
        using Traits = variable_traits<MemberPtr>;
        using ClassType = typename Traits::class_type;
        using MemberType = typename Traits::member_type;
        constexpr auto ptr = Traits::ptr_;

        auto getter = [ptr](const Any& instance) -> Any {
            const ClassType* inst = any_cast<ClassType>(instance);
            if (!inst) throw std::runtime_error("Type mismatch");
            return make_cref(inst->*ptr);
        };

        auto setter = [ptr](Any& instance, const Any& value) -> bool {
            ClassType* inst = any_cast<ClassType>(instance);
            if (!inst) return false;
            const MemberType* val = any_cast<MemberType>(value);
            if (!val) return false;
            inst->*ptr = *val;
            return true;
        };

        return MemberVariable{name, GetType<MemberType>(), getter, setter};
    }
};
```

**设计亮点**：
- getter 返回 `make_cref`（const 引用），避免不必要的拷贝
- setter 返回 bool 表示是否成功，提供错误处理机制

---

### 4.5 MemberContainer.h / MemberContainer.cpp

**作用**：存储容器类型成员的元数据，提供类型擦除的容器操作

**关键内容**：

```cpp
struct ContainerOperations {
    std::function<size_t(const Any&)> size;
    std::function<Any(const Any&, size_t)> at;
    std::function<void(Any&, const Any&)> push_back;
    std::function<void(Any&)> clear;
    std::function<Any(const Any&)> begin_iter;  // 返回首元素引用
    std::function<Any(const Any&)> end_iter;    // 返回尾后状态标记
};

class MemberContainer {
public:
    std::string name_;
    const Type* containerType_;
    const Type* elementType_;
    ContainerOperations ops_;

    template <typename ContainerType>
    static MemberContainer Create(const std::string& name);
};
```

**Create 实现**：

```cpp
template <typename T>
static MemberContainer Create(const std::string& name) {
    using ElementType = typename T::value_type;

    ContainerOperations ops;
    ops.size = [](const Any& any) -> size_t {
        auto* vec = any_cast<T>(any);
        return vec ? vec->size() : 0;
    };

    ops.at = [](const Any& any, size_t index) -> Any {
        auto* vec = any_cast<T>(any);
        if (vec && index < vec->size()) {
            return make_cref((*vec)[index]);
        }
        throw std::out_of_range("Index out of range");
    };

    ops.push_back = [](Any& any, const Any& elem) {
        auto* vec = any_cast<T>(any);
        const auto* val = any_cast<ElementType>(elem);
        if (vec && val) {
            vec->push_back(*val);
        }
    };

    ops.clear = [](Any& any) {
        auto* vec = any_cast<T>(any);
        if (vec) vec->clear();
    };

    return MemberContainer{name, GetType<T>(), GetType<ElementType>(), ops};
}
```

**设计亮点**：
- 不依赖虚函数，使用 `std::function` 实现类型擦除
- 支持标准库所有容器接口（vector, list, deque 等）

---

### 4.6 Any.h / Any.cpp

**作用**：类型擦除容器，核心运行时反射接口

**关键内容**：

```cpp
class Any {
public:
    // 类型信息
    const Type* typeInfo;

    // 存储方式
    enum class StorageType { Empty, Copy, Ref, CRef };
    StorageType storageType;

    // 类型擦除存储
    void* data;
    std::shared_ptr<void> holder;

    // 算术操作
    Any operator+(const Any& other) const;
    Any operator-(const Any& other) const;
    // ... 其他运算符

    // 枚举操作
    Any to_underlying() const;
    Any from_underlying(int64_t value) const;

    // 容器操作
    size_t container_size() const;
    Any container_at(size_t index) const;
    void container_push_back(const Any& elem);
    void container_clear();

    // 成员访问
    Any get_member(const std::string& memberName) const;
    bool set_member(const std::string& memberName, const Any& value);

    // 函数调用
    template<typename... Args>
    Any invoke(const std::string& funcName, Args&&... args);

    template<typename... Args>
    Any invoke(size_t funcIndex, Args&&... args);
};
```

**创建函数**：

```cpp
// 创建拷贝（拥有所有权）
template <typename T>
Any make_copy(const T& value);

// 创建引用（不拥有所有权）
template <typename T>
Any make_ref(T& value);

// 创建 const 引用
template <typename T>
Any make_cref(const T& value);
```

**设计亮点**：
- 支持三种存储方式：拷贝、引用、const 引用
- 使用 `shared_ptr<void>` 管理拷贝对象的生命周期
- 提供统一的操作接口，内部根据 `Type::Kind` 分发

---

### 4.7 invoke_impl.h

**作用**：实现 Any::invoke 的模板函数，单独文件避免循环依赖

**关键内容**：

```cpp
namespace detail {
    // 将参数包转换为 vector<Any>
    inline void pack_args(std::vector<Any>&) {}

    template<typename T, typename... Rest>
    void pack_args(std::vector<Any>& vec, T&& arg, Rest&&... rest) {
        if constexpr (std::is_lvalue_reference_v<T>) {
            vec.push_back(make_ref(arg));
        } else {
            vec.push_back(make_copy(std::forward<T>(arg)));
        }
        pack_args(vec, std::forward<Rest>(rest)...);
    }
}

template<typename... Args>
Any Any::invoke(const std::string& funcName, Args&&... args) {
    const Class* classInfo = typeInfo->AsClass();
    const MemberFunction* func = classInfo->FindFunction(funcName);
    if (!func) throw std::runtime_error("Function not found");

    std::vector<Any> anyArgs;
    detail::pack_args(anyArgs, std::forward<Args>(args)...);
    return func->Invoke(*this, anyArgs);
}
```

**设计决策**：
- 左值引用参数使用 `make_ref`，右值参数使用 `make_copy`
- 递归展开参数包，避免使用折叠表达式（兼容性考虑）

---

### 4.8 container_operations.h

**作用**：定义容器操作的类型擦除接口（已整合到 MemberContainer.h）

**说明**：此文件定义了 `ContainerOperations` 结构体，现已包含在 `MemberContainer.h` 中。

---

### 4.9 TypeRegistry.h / TypeRegistry.cpp

**作用**：全局类型注册表，运行时查询类型信息

**关键内容**：

```cpp
class TypeRegistry {
public:
    static TypeRegistry& Instance();

    void RegisterType(const std::string& name, const Type* type);
    const Type* GetType(const std::string& name) const;

private:
    std::unordered_map<std::string, const Type*> types_;
};

// 工具函数
template <typename T>
const Type* GetType() {
    return TypeRegistry::Instance().GetType(typeid(T).name());
}
```

**用途**：
- 在 `ClassFactory::Register` 中注册类型
- 在运行时通过名称查询类型元数据

---

### 4.10 Enum.h / Enum.cpp

**作用**：表示枚举类型的元数据

**关键内容**：

```cpp
class Enum : public Type {
public:
    struct EnumValue {
        std::string name;
        int64_t value;
    };

    std::vector<EnumValue> values_;
    const Type* underlyingType_; // 底层整数类型

    // 枚举与整数转换
    int64_t ToUnderlying(const Any& enumValue) const;
    Any FromUnderlying(int64_t value) const;
};

template <typename T>
class EnumFactory {
public:
    EnumFactory& Register(const std::string& name);
    EnumFactory& AddValue(const std::string& valueName, T value);
};
```

**用途**：
- 存储枚举值名称和数值的映射
- 支持枚举与底层整数类型的转换

---

### 4.11 Arithmetic.h / Arithmetic.cpp

**作用**：表示算术类型（int, float, double 等）的元数据

**关键内容**：

```cpp
class Arithmetic : public Type {
public:
    enum class Category { Integral, FloatingPoint };

    Category category_;
    size_t size_;
    bool isSigned_;

    // 算术操作
    Any Add(const Any& lhs, const Any& rhs) const;
    Any Subtract(const Any& lhs, const Any& rhs) const;
    Any Multiply(const Any& lhs, const Any& rhs) const;
    Any Divide(const Any& lhs, const Any& rhs) const;
};
```

**支持的操作**：
- 加减乘除、取模
- 自增自减
- 比较运算

---

### 4.12 Pointer.h / Pointer.cpp

**作用**：表示指针类型的元数据

**关键内容**：

```cpp
class Pointer : public Type {
public:
    const Type* pointeeType_; // 指向的类型

    // 指针解引用
    Any Dereference(const Any& ptr) const;
    Any AddressOf(Any& value) const;
};
```

---

### 4.13 Void.h / Void.cpp

**作用**：表示 void 类型（用于函数返回值）

**关键内容**：

```cpp
class Void : public Type {
public:
    Void();
};
```

---

## 5. 核心设计决策

### 5.1 宏与模板的平衡设计

为了保持代码可维护性，静态反射系统采用了分层设计：

**设计原则**：
1. **复杂模板逻辑外置**：将复杂的模板实现放在 `detail` 命名空间中
   - 例如：`find_function_index_impl`、`invoke_by_index_impl`、`get_by_index_impl` 等
2. **宏内简洁包装**：宏内只生成数据（tuple、type_list）和必要的模板包装函数
3. **易读性与功能性兼顾**：既保持宏的相对简洁，又提供完整的编译期反射功能

**优势**：
- **可读性**：复杂逻辑与宏分离，降低理解难度
- **调试友好**：模板错误信息更清晰
- **IDE 支持**：IDE 可以正确分析和补全 `detail` 命名空间中的模板函数
- **可维护性**：修改模板实现无需改动宏定义

---

### 5.2 为什么静态反射不支持运行时名字调用？

**原因**：不同函数的返回类型不同，无法在运行时统一返回类型。

**C++ 类型系统限制**：
```cpp
// 编译失败：返回类型不一致
auto invoke_by_name(std::string_view name, ...) {
    if (name == "getAge") return instance.getAge();  // int
    if (name == "getName") return instance.getName(); // std::string
}
```

**解决方案**：
- 使用 `find_function_index(name)` 在**编译期**查找索引
- 使用 `invoke<Index>(...)` 在**编译期**调用
- 这样保持零开销抽象，同时提供名字查找功能

---

### 5.3 编译期对象的存储位置

#### 核心问题

**`constexpr` 对象在哪里存储？如何实现编译期计算？**

#### 存储机制

`constexpr` 变量虽然在编译期计算，但在运行时仍需要存储空间。它们存储在二进制文件的**只读数据段（`.rodata` 或 `.rdata`）**中。

**示例**：

```cpp
// 静态反射的元数据
static constexpr auto variables = std::make_tuple(
    field_traits{&Person::name, "name"},
    field_traits{&Person::age, "age"}
);
```

**内存布局**：

```
Windows/Linux 进程内存布局：

高地址 ↑
┌──────────────────────────────────┐
│  Stack (栈)                      │
│  - 局部变量 (如 Person p)        │
│  - 函数调用栈                    │
├──────────────────────────────────┤
│  [大片地址空间]                  │
├──────────────────────────────────┤
│  .data / .bss (可写数据段)       │
│  - 运行时静态变量                │
│  - 全局变量                      │
├──────────────────────────────────┤
│  .rodata / .rdata (只读数据段)   │  ← constexpr 对象在这里！
│  - variables tuple               │
│  - functions tuple               │
│  - 字符串字面量 "name", "age"    │
│  - const 全局变量                │
├──────────────────────────────────┤
│  .text (代码段)                  │
│  - 函数的机器码                  │
└──────────────────────────────────┘
低地址 ↓
```

#### 实际验证

运行 `tests/constexpr_demo.cpp` 可以看到地址分布：

```
Compile-time objects (constexpr):
  fields object address:           00007FF6EF51C080  ← .rodata 段
  first element name_ points to:   00007FF6EF51C23C

Runtime objects:
  runtime_fields object address:   00007FF6EF51F000  ← .data 段（更高地址）

Stack objects:
  stack_field address:             0000006251EFF678  ← 栈（完全不同的地址区域）

Reflection metadata addresses:
  PersonType::variables address:   00007FF6EF51C...  ← .rodata 段
  PersonType::functions address:   00007FF6EF51C...  ← .rodata 段
```

**关键发现**：

1. **constexpr 对象在低地址**：与字符串字面量在同一区域
2. **运行时静态对象在中等地址**：.data 段
3. **栈对象在高地址**：完全不同的地址空间

#### 编译期计算过程

**问题**：`field_traits` 是对象，为什么能在编译期创建？

**答案**：

1. **constexpr 构造函数**：
   ```cpp
   struct field_traits {
       constexpr field_traits(T ptr, std::string_view name)
           : ptr_(ptr), name_(strip_scope(name)) {}

       T ptr_;
       std::string_view name_;
   };
   ```

2. **宏展开后的代码**：
   ```cpp
   // 用户写的代码
   variables(
       var(&Person::name),
       var(&Person::age)
   )

   // 宏展开后
   static constexpr auto variables = std::make_tuple(
       field_traits{&Person::name, "name"},  // 编译期创建
       field_traits{&Person::age, "age"}     // 编译期创建
   );
   ```

3. **编译器执行过程**：
   - 在编译期调用 `field_traits` 的 constexpr 构造函数
   - 计算 `strip_scope("name")` 返回 "name"
   - 将整个 tuple 的内容"烧录"到 .rodata 段
   - 运行时直接从只读内存中使用

4. **编译期名字查找**：
   ```cpp
   constexpr int name_idx = PersonType::find_variable_index("name");
   // 编译器执行：
   // 1. 读取 PersonType::variables (constexpr tuple)
   // 2. 遍历 tuple，比较每个元素的 name_
   // 3. 找到匹配的索引 0
   // 4. 将结果 0 直接内嵌到代码中
   ```

#### constexpr 函数的双重性质

`constexpr` 函数可以在**编译期或运行期**执行：

```cpp
constexpr int find_variable_index(std::string_view name);

// 编译期调用（所有参数都是编译期常量）
constexpr int idx = PersonType::find_variable_index("name");  // 编译期执行

// 运行期调用（参数是运行期变量）
std::string runtime_name = "age";
int idx2 = PersonType::find_variable_index(runtime_name);     // 运行期执行
```

**编译期调用的条件**：
- 函数声明为 `constexpr`
- 所有参数在编译期已知
- 函数体可以在编译期求值（无 I/O、无动态分配等）

#### 性能优势

**零运行时开销**：

```cpp
// 编译期查找
constexpr int name_idx = PersonType::find_variable_index("name");
auto& name = PersonType::get<name_idx>(person);

// 编译后等价于
auto& name = PersonType::get<0>(person);
// 进一步内联后等价于
auto& name = person.name;
```

整个查找过程在编译期完成，运行时直接访问成员，**完全零开销**！

#### 对比三种存储方式

| 存储类型 | 示例 | 内存段 | 地址范围 | 初始化时机 | 可修改 |
|---------|------|--------|---------|-----------|-------|
| **constexpr 对象** | `static constexpr auto vars` | .rodata | 低地址 | 编译期 | ❌ 否 |
| **运行时静态对象** | `static auto runtime_vars` | .data | 中等地址 | 运行期 | ✅ 是 |
| **栈对象** | `field_traits local_var` | stack | 高地址 | 运行期 | ✅ 是 |

**总结**：`constexpr` 对象虽然在编译期计算，但确实需要存储空间，存储在只读数据段中。这使得反射元数据可以在运行时被访问（取地址、传引用），同时保证了数据不可修改的安全性。

---

### 5.4 为什么 Any 需要三种存储模式？

**三种模式**：
1. **Copy**：拥有数据所有权，用于临时对象和返回值
2. **Ref**：引用外部对象，用于修改原对象
3. **CRef**：const 引用，用于只读访问，避免拷贝

**设计优势**：
- 性能优化：避免不必要的拷贝
- 语义清晰：明确所有权关系
- 安全性：const 引用防止意外修改

---

## 6. 性能特性

| 特性 | 静态反射 | 动态反射 |
|------|---------|---------|
| 类型安全 | 编译期保证 | 运行时检查 |
| 运行时开销 | 零开销（内联优化） | 虚函数调用 + 类型转换 |
| 灵活性 | 需要编译期已知类型 | 完全运行时多态 |
| 代码膨胀 | 模板实例化可能增加二进制大小 | 类型擦除统一接口 |
| 适用场景 | 性能敏感、类型已知 | 插件系统、脚本绑定 |

---

## 7. 文件依赖关系

```
static_refl/reflect_core.h
  ├─ type_list.h
  ├─ field_traits.h
  ├─ function_traits.h
  ├─ variable_traits.h
  └─ container_traits.h

dynamic_refl/dynamic_reflect_core.h
  ├─ Type.h
  ├─ TypeRegistry.h
  ├─ Class.h
  │   ├─ MemberFunction.h
  │   │   └─ invoke_impl.h (includes Any.h)
  │   ├─ MemberVariable.h
  │   └─ MemberContainer.h
  ├─ Enum.h
  ├─ Arithmetic.h
  ├─ Pointer.h
  ├─ Void.h
  └─ Any.h
```

**注意**：`invoke_impl.h` 单独存在是为了打破 `Any.h` 和 `MemberFunction.h` 之间的循环依赖。

---

## 8. 扩展指南

### 添加新的动态反射类型

1. 继承 `Type` 类
2. 在 `Type::Kind` 枚举中添加新类型
3. 在 `Type` 类中添加对应的 `AsXxx()` 方法
4. 实现类型特定的操作

### 添加新的容器操作

在 `ContainerOperations` 中添加新的 `std::function` 字段，并在 `MemberContainer::Create` 中实现。

### 支持新的静态反射字段类型

在 `ClassFactory::Add` 中添加新的 `if constexpr` 分支进行类型判断。

---

## 9. 编译要求

- **C++ 标准**：C++17 或更高
  - 需要 `if constexpr`
  - 需要 `std::void_t`
  - 需要折叠表达式
  - 需要 `auto` 模板参数（C++17）

- **编译器支持**：
  - GCC 7+
  - Clang 5+
  - MSVC 2019+

---

## 10. 设计哲学

1. **零开销抽象**：静态反射应达到手写代码的性能
2. **类型安全**：尽可能在编译期发现错误
3. **易用性**：简洁的宏接口 + 灵活的模板工具
4. **可维护性**：复杂逻辑与宏分离，保持代码结构清晰
5. **互补设计**：静态反射和动态反射各有优势，可组合使用

---

## 结语

本反射系统通过精心设计的**双轨架构**，在**性能**（静态反射）和**灵活性**（动态反射）之间取得平衡。静态反射通过编译期元编程实现零开销抽象，动态反射通过类型擦除提供运行时灵活性。两种方式可以根据具体场景灵活选择和组合使用。

对于大多数应用场景，推荐：
- **性能关键路径**：使用静态反射
- **动态配置/脚本绑定**：使用动态反射 + Any 类型
- **混合使用**：静态反射用于内部实现，动态反射用于对外接口
